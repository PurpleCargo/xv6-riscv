# Informe Tarea 3 - Sistemas Operativos, Sec. 1
### Nombre: Eduardo Torres Lagos
### Sistema: Windows 11, WSL2, Ubuntu 22.04.3 LTS

## Ignorar archivo INFORME.md, corresponde a tarea 1

## Funcionamiento y lógica de la protección de memoria

La protección de la memoria en los OS controla el acceso a diferentes regiones de la memoria de un proceso, evitando lecturas o escrituras no
deseadas, esto se hace mediante tablas de páginas, que asignan direcciones de memoria virtual a direcciones de memoria física.

Cada entrada de la tabla de página (PTE) incluye flags para especificar permisos de acceso:

Read (R) para permitir lectura en la region de memoria
Write (W) para permitir escritura
Execute (X) para ejecutar código en esa region

## Modificaciones realizadas

En total agregué 4 funciones a proc.c para implementar las modificaciones requeridas:

sys_mprotect: 

Esta función itera por cada página en la región especificada por addr y len, y luego limpia el bit PTE_W en cada PTE para volverlo solo lectura.

sys_munprotect:

Esta función itera por la misma región, pero configura (set) el bit PTE_W en cada PTE para que se pueda escribir nuevamente

En general estas funciones se aseguran de que addr esté alineado al límite de la páginan, sino retorna un error. Verifican que la region
addr, addr + len esté dentro de la region de memoria válida del proceso.

Y en cuanto a la iteración de páginas:

encuentran el PTE utilizando la función walk(proc->pagetable, addr, 0), si walk retorna 0, la página no existe, por lo que retorna un error.
Borra el bit PTE_W para que la página sea de solo lectura y luego usa sfence_vma si es necesario para actualizar las entradas TLB

set_page_readonly y set_page_writable:
estas funciones auxiliares encapsulan la lógica de permisos para cada página

## Dificultades encontradas

Tuve problemas con la implementación del programa de prueba, dado que los headers types.h y stat.h me tiraban error al compilar, asumo que porque se ubican en el kernel
y no en el directorio user, por lo que modifiqué el Makefile para que busque los headers en el kernel también

CFLAGS += -I. -I../kernel

pero no funcionó, por lo que tuve que agregar el path directamente en el programa de prueba para lidiar con eso.

La otra dificultad que encontré es que tuve un output incorrecto al ejecutar el programa (xv6 se compila bien, el programa de pruebas se compila
y ejecuta, pero el output muestra que ambas llamadas de sistema fallan). No fui capaz de solucionar este problema pero es probable
que se relacione a la lógica de implementación de estas funciones.